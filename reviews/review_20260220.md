# GridShield Code Review ‚Äî 20 Februari 2026

**Reviewer**: AI Code Review  
**Commit**: Current `main` branch  
**Scope**: Full codebase audit (24 files, ~3,500 LOC)

---

## Ringkasan Eksekutif

Arsitektur GridShield **sangat solid** ‚Äî layered design, HAL pattern, `Result<T>` monad, dan zero-heap-allocation sangat profesional untuk proyek embedded. Namun ditemukan **4 bug kritis**, **5 isu penting**, dan beberapa area perbaikan minor.

---

## Skor Kualitas

| Kategori | Skor | Catatan |
|---|---|---|
| Arsitektur | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Layered design, clean interfaces, HAL |
| Code Style | ‚≠ê‚≠ê‚≠ê‚≠ê | Konsisten, komentar baik |
| Error Handling | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | `Result<T>` monad, propagasi error bersih |
| Security | ‚≠ê‚≠ê‚≠ê | Crypto primitif bagus, tapi ada bug ECDSA & belum ada AES-GCM |
| Embedded Focus | ‚≠ê‚≠ê‚≠ê‚≠ê | Zero-alloc, tapi ISR delay bug kritis |
| Testing | ‚≠ê | Belum ada test sama sekali |
| Dokumentasi | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | README, API, Architecture, Quickstart lengkap |
| Build System | ‚≠ê‚≠ê‚≠ê‚≠ê | CMake + PlatformIO, tapi path hardcoded |

---

## Flow Perbaikan

Urutan perbaikan di bawah ini didesain agar: bug kritis diperbaiki dulu, lalu fondasi kode diperkuat, baru fitur baru ditambahkan.

---

### ‚úÖ ~~Fase 1 ‚Äî Bug Kritis~~ SELESAI (20 Feb 2026)

> Semua 4 bug kritis telah diperbaiki. Perubahan tercatat di `CHANGELOG.md` v1.0.1.

| # | Bug | File yang diubah | Status |
|---|---|---|---|
| 1.1 | ECDSA Signature Overflow | `crypto.cpp` | ‚úÖ Fixed |
| 1.2 | ISR Delay Hang | `tamper.hpp`, `tamper.cpp`, `system.cpp` | ‚úÖ Fixed |
| 1.3 | Wrong Macro Names | `mock_platform.hpp` | ‚úÖ Fixed |
| 1.4 | StaticBuffer Alignment | `types.hpp` | ‚úÖ Fixed |

#### 1.1 Fix ECDSA Signature Buffer Overflow

**File**: `src/common/security/crypto.cpp` ‚Äî fungsi `sign()` dan `verify()`  
**Masalah**: OpenSSL `ECDSA_sign()` menghasilkan signature DER-encoded (~70-72 bytes), tapi buffer hanya 64 bytes (`ECC_SIGNATURE_SIZE`). Ini menyebabkan **buffer overflow**.

**Solusi**:
```cpp
// Di sign(): gunakan buffer DER sementara lalu konversi ke raw (r || s)
uint8_t der_sig[72];
unsigned int der_len = sizeof(der_sig);
ECDSA_sign(0, hash, SHA256_HASH_SIZE, der_sig, &der_len, key);

// Decode DER ‚Üí raw r,s (masing-masing 32 byte)
ECDSA_SIG* sig = d2i_ECDSA_SIG(nullptr, &der_sig_ptr, der_len);
const BIGNUM *r, *s;
ECDSA_SIG_get0(sig, &r, &s);
BN_bn2binpad(r, signature_out, 32);
BN_bn2binpad(s, signature_out + 32, 32);
ECDSA_SIG_free(sig);
```

Untuk `verify()`, lakukan sebaliknya: konversi raw (r || s) ‚Üí DER sebelum panggil `ECDSA_verify()`:
```cpp
ECDSA_SIG* sig = ECDSA_SIG_new();
BIGNUM* r = BN_bin2bn(signature, 32, nullptr);
BIGNUM* s = BN_bin2bn(signature + 32, 32, nullptr);
ECDSA_SIG_set0(sig, r, s);

uint8_t der_buf[72];
uint8_t* der_ptr = der_buf;
int der_len = i2d_ECDSA_SIG(sig, &der_ptr);
int valid = ECDSA_verify(0, hash, SHA256_HASH_SIZE, der_buf, der_len, key);
ECDSA_SIG_free(sig);
```

**Test**: Buat unit test yang sign & verify pesan, pastikan round-trip berhasil.

---

#### 1.2 Fix ISR Delay Hang

**File**: `src/common/hardware/tamper.cpp` ‚Äî fungsi `handle_tamper_event()`  
**Masalah**: `delay_ms()` dipanggil di dalam ISR handler. Di Arduino, `millis()` berhenti selama ISR, sehingga `delay()` akan **hang selamanya**.

**Solusi**: Ubah ke timestamp-based debouncing:
```cpp
// Di header tamper.hpp, tambahkan member:
volatile core::timestamp_t last_trigger_time_;

// Di handle_tamper_event():
void TamperDetector::handle_tamper_event() noexcept {
    if (!initialized_ || platform_ == nullptr) return;
    
    // ISR hanya set flag, TANPA delay
    is_tampered_ = true;
    tamper_type_ = TamperType::CasingOpened;
    tamper_timestamp_ = platform_->time->get_timestamp_ms();
}

// Debounce dilakukan di main loop via fungsi baru:
core::Result<void> TamperDetector::poll() noexcept {
    if (!is_tampered_) return core::Result<void>();
    
    auto now = platform_->time->get_timestamp_ms();
    if (now - tamper_timestamp_ < config_.debounce_ms) {
        return core::Result<void>(); // masih dalam debounce window
    }
    
    // Konfirmasi sensor setelah debounce
    auto read_result = platform_->gpio->read(config_.sensor_pin);
    if (read_result.is_ok() && read_result.value()) {
        // False trigger ‚Äî reset
        is_tampered_ = false;
        tamper_type_ = TamperType::None;
    }
    
    return core::Result<void>();
}
```

Panggil `tamper_detector_.poll()` dari `process_cycle()`.

---

#### 1.3 Fix Macro Names di `mock_platform.hpp`

**File**: `include/platform/mock_platform.hpp`  
**Masalah**: Menggunakan `PLATFORM_NATIVE` (bukan `GS_PLATFORM_NATIVE`) dan `MAKE_ERROR` (bukan `GS_MAKE_ERROR`).

**Solusi**: Find & replace semua instance:
- `PLATFORM_NATIVE` ‚Üí `GS_PLATFORM_NATIVE` (8 lokasi)
- `MAKE_ERROR(` ‚Üí `GS_MAKE_ERROR(` (8 lokasi)

---

#### 1.4 Fix `StaticBuffer` Alignment

**File**: `include/common/core/types.hpp` ‚Äî class `StaticBuffer<T, N>`  
**Masalah**: Storage array `char storage_[N * sizeof(T)]` tidak memenuhi alignment requirement dari type `T`. Jika `T` punya `alignas(8)` (misal `MeterReading`), maka placement new pada unaligned memory = **undefined behavior**.

**Solusi**:
```diff
-    char storage_[N * sizeof(T)];
+    alignas(T) char storage_[N * sizeof(T)];
```

---

### üü° Fase 2 ‚Äî Isu Fungsional Penting

> Fitur yang seharusnya bekerja tapi tidak berfungsi sama sekali.

#### 2.1 Implementasi Arduino Interrupt

**File**: `include/arduino/platform_arduino.hpp` ‚Äî class `ArduinoInterrupt`  
**Masalah**: Semua method (`attach`, `detach`, `enable`, `disable`) adalah **no-op** ‚Äî tidak ada panggilan ke `attachInterrupt()` Arduino. Tamper detection tidak akan berfungsi di hardware.

**Solusi**:
```cpp
core::Result<void> attach(uint8_t pin, TriggerMode mode,
                          InterruptCallback callback, 
                          void* context) noexcept override {
    int arduino_mode;
    switch (mode) {
        case TriggerMode::Rising:  arduino_mode = RISING;  break;
        case TriggerMode::Falling: arduino_mode = FALLING; break;
        case TriggerMode::Change:  arduino_mode = CHANGE;  break;
        case TriggerMode::Low:     arduino_mode = LOW;     break;
        default: return GS_MAKE_ERROR(core::ErrorCode::InvalidParameter);
    }
    
    // Simpan context untuk dipanggil nanti
    stored_callbacks_[pin] = callback;
    stored_contexts_[pin] = context;
    
    int interrupt_num = digitalPinToInterrupt(pin);
    if (interrupt_num == NOT_AN_INTERRUPT) {
        return GS_MAKE_ERROR(core::ErrorCode::InvalidParameter);
    }
    
    // Catatan: Arduino attachInterrupt tidak support context pointer
    // Perlu static trampoline per pin
    attachInterrupt(interrupt_num, get_trampoline(pin), arduino_mode);
    return core::Result<void>();
}
```

> [!NOTE]
> Arduino `attachInterrupt()` tidak mendukung context pointer. Perlu solusi dengan static trampoline function per pin yang digunakan. Ini bisa jadi rumit ‚Äî alternatifnya polling berbasis timer.

---

#### 2.2 Fix `StaticBuffer` FIFO Behavior

**File**: `include/common/core/types.hpp`  
**Masalah**: `StaticBuffer::pop()` menghapus dari **belakang** (stack/LIFO), tapi `AnomalyDetector::update_profile()` menggunakannya sebagai FIFO (hapus yang paling lama). Akibatnya, data terbaru justru yang dihapus.

**Solusi**: Tambahkan `pop_front()` atau ubah `StaticBuffer` ke ring buffer:
```cpp
bool pop_front(T& item) {
    if (size_ == 0) return false;
    T* ptr = reinterpret_cast<T*>(&storage_[0]);
    item = GS_MOVE(*ptr);
    ptr->~T();
    
    // Shift semua elemen ke kiri
    for (size_t i = 1; i < size_; ++i) {
        T* src = reinterpret_cast<T*>(&storage_[i * sizeof(T)]);
        T* dst = reinterpret_cast<T*>(&storage_[(i - 1) * sizeof(T)]);
        new (dst) T(GS_MOVE(*src));
        src->~T();
    }
    --size_;
    return true;
}
```

Lalu ganti `recent_readings_.pop(temp)` di `detector.cpp` menjadi `recent_readings_.pop_front(temp)`.

> [!TIP]
> Alternatif yang lebih efisien: implementasikan **ring buffer** (`RingBuffer<T, N>`) dengan head/tail pointer, supaya pop_front O(1) bukan O(N).

---

### üü† Fase 3 ‚Äî Perkuatan Security

> Meningkatkan postur keamanan dari "signed only" ke "signed + encrypted"

#### 3.1 Implementasi AES-256-GCM

**File**: `src/common/security/crypto.cpp`  
**Masalah**: `encrypt_aes_gcm()` dan `decrypt_aes_gcm()` return `NotImplemented`.

**Solusi**:
- **Native**: Gunakan OpenSSL `EVP_aes_256_gcm()`
- **Arduino**: Gunakan library `Crypto` oleh Rhys Weatherley yang sudah ada di `lib_deps` (`GCM<AES256>`)

---

#### 3.2 Perbaiki Arduino RNG

**File**: `include/arduino/platform_arduino.hpp` ‚Äî `ArduinoCrypto::random_bytes()`  
**Masalah**: `random()` Arduino bukan cryptographically secure RNG. Seeding dengan `analogRead()` saja tidak cukup untuk operasi kriptografi.

**Solusi**: Gunakan hardware RNG jika tersedia (ESP32), atau campurkan beberapa entropy source + hash untuk Arduino AVR.

---

### üîµ Fase 4 ‚Äî Cleanup & Quality

> Pembersihan kode dan peningkatan maintainability

#### 4.1 Hapus Legacy Utility Files

**Files**:
- `include/common/utils/gs_utils.hpp` ‚Äî duplikat `GS_MOVE` di global namespace
- `include/common/utils/gs_typetraits.hpp` ‚Äî duplikat `remove_reference` di global namespace

Kedua file ini sudah di-supersede oleh `gs_macros.hpp`. Hapus dan pastikan tidak ada include yang rusak.

---

#### 4.2 Portabilitas CMake

**File**: `CMakeLists.txt` line 89-91  
**Masalah**: OpenSSL path hardcoded ke `C:/Program Files/OpenSSL-Win64`.

**Solusi**:
```cmake
find_package(OpenSSL REQUIRED)
target_link_libraries(${PROJECT_NAME} OpenSSL::SSL OpenSSL::Crypto)
```

---

#### 4.3 Kurangi Repetitif `#if GS_PLATFORM_NATIVE`

Di banyak file (`packet.cpp`, `crypto.cpp`, `types.hpp`), ada pattern berulang:
```cpp
#if GS_PLATFORM_NATIVE
    std::memcpy(dst, src, len);
#else
    memcpy(dst, src, len);
#endif
```

**Solusi**: Buat wrapper macro di `gs_macros.hpp`:
```cpp
#if GS_PLATFORM_NATIVE
    #include <cstring>
    #define GS_MEMCPY(dst, src, len) std::memcpy(dst, src, len)
    #define GS_MEMSET(dst, val, len) std::memset(dst, val, len)
#else
    #include <string.h>
    #define GS_MEMCPY(dst, src, len) memcpy(dst, src, len)
    #define GS_MEMSET(dst, val, len) memset(dst, val, len)
#endif
```

---

### üü¢ Fase 5 ‚Äî Testing

> Menambahkan test suite untuk mencegah regresi

#### 5.1 Setup Test Framework

- **Native**: Gunakan [GoogleTest](https://github.com/google/googletest) atau [Catch2](https://github.com/catchorg/Catch2) (header-only, cocok untuk embedded)
- **PlatformIO**: Gunakan `[env:native]` dengan `test_framework = unity`

#### 5.2 Target Test Cases

| Module | Test |
|---|---|
| `Result<T>` | Construct success/error, move semantics, `value_or()` |
| `StaticBuffer` | Push/pop/clear, capacity limits, FIFO behavior |
| `ByteArray` | Append, overflow detection, clear |
| `ECCKeyPair` | Generate, load, clear, secure erasure |
| `CryptoEngine` | Sign ‚Üí Verify round-trip, hash consistency |
| `SecurePacket` | Build ‚Üí Serialize ‚Üí Parse round-trip |
| `TamperDetector` | Initialize, interrupt trigger, debounce, reset |
| `AnomalyDetector` | Normal readings, zero consumption, spike detection |
| `CrossLayerValidation` | Priority escalation logic |

---

## Estimasi Waktu Perbaikan

| Fase | Effort | Estimasi |
|---|---|---|
| Fase 1 ‚Äî Bug Kritis | 4 fix items | 2-3 jam |
| Fase 2 ‚Äî Isu Fungsional | 2 items | 2-3 jam |
| Fase 3 ‚Äî Security | 2 items | 4-6 jam |
| Fase 4 ‚Äî Cleanup | 3 items | 1-2 jam |
| Fase 5 ‚Äî Testing | Framework + 9 test suites | 6-8 jam |
| **Total** | | **15-22 jam** |

---

## Catatan untuk Tim

- Proyek ini sudah punya **fondasi arsitektur yang sangat kuat** ‚Äî perbaikan di atas tidak perlu refactor besar
- Bug Fase 1 **wajib diperbaiki** sebelum demo atau deploy ke hardware
- Fase 3 (AES-GCM) bisa ditunda jika timeline ketat, tapi harus masuk v1.1
- Fase 5 (testing) sebaiknya dimulai paralel dengan Fase 2

> [!IMPORTANT]
> Jangan deploy ke Arduino Mega sebelum **Fase 1.2** (ISR delay) dan **Fase 2.1** (Arduino interrupt) selesai ‚Äî sistem akan hang saat tamper terdeteksi.
